@startuml Query Optimizer Class Diagram

title Query Optimizer - Class Diagram 


' Komponen utama interface
package "Query Optimizer" {
    class OptimizationEngine {
        - parser: Parser
        - validator: QueryValidator
        - plan_optimizer: PlanOptimizer
        - cost_calculator: CostCalculator
        - use_real_storage: bool
        + __init__(use_real_storage: bool = False): void
        + parse_query(query: str): ParsedQuery
        + optimize_query(parsed_query: ParsedQuery): ParsedQuery
        + get_cost(parsed_query: ParsedQuery): int
    }
}

' Struktur tree
package "Komponen Tree" {
    class ParsedQuery {
        - query: str
        - query_tree: QueryTree
        - tables: List[str]
        + __init__(query: str, query_tree: QueryTree): void
        + collect_tables(node: QueryTree): void
        + print_tree(node: QueryTree = None, level: int = 0): void
    }

    class QueryTree {
        - type: str
        - val: Any
        - childs: List[QueryTree]
        - parent: Optional[QueryTree]
        + __init__(type: str, val: Any, childs: List[QueryTree], parent: Optional[QueryTree]): void
        + add_child(child: QueryTree): void
        + print_tree(level: int = 0): void
        + condition_node_to_string(node: ConditionNode): str
        + __str__(): str
    }
}

' Tipe node dan kondisi
package "Komponen Node" {
    enum NodeType {
        PROJECT
        SELECT
        TABLE
        JOIN
        CARTESIAN_PRODUCT
        NATURAL_JOIN
        HASH_JOIN
        UPDATE
        SET
        ORDER_BY
        GROUP_BY
        HAVING
        LIMIT
        CONDITION
        + __str__(): str
    }

    abstract class ConditionNode {
    }

    class ConditionOperator {
        - operator: str
        - left: ConditionNode
        - right: ConditionNode
        + __init__(operator: str, left: ConditionNode, right: ConditionNode): void
        + __eq__(other: ConditionOperator): bool
        + __repr__(): str
    }

    class ConditionLeaf {
        - condition: str
        + __init__(condition: str): void
        + __eq__(other: ConditionLeaf): bool
        + __repr__(): str
    }
}

' Komponen parser
package "Komponen Parser" {
    class Parser {
        - lexer: Lexer
        + __init__(): void
        + parse_query(query: str): ParsedQuery
        + parse_condition(condition_tokens: List[str]): ConditionNode
    }

    class Lexer {
        + tokenize(query: str): List[str]
        + KEYWORDS: Set[str]
    }

    class QueryValidator {
        + validate_parsed_query(parsed_query: ParsedQuery): Tuple[bool, List[str]]
        - _validate_tree_structure(node: QueryTree, visited: Set): List[str]
    }
}

' Komponen optimizer
package "Komponen Optimisasi" {
    class PlanOptimizer {
        - rules: OptimizationRules
        - cost_calculator: CostCalculator
        - use_real_storage: bool
        + __init__(use_real_storage: bool = False): void
        + optimize_tree(parsed_query: ParsedQuery): ParsedQuery
        + optimize_tree_with_genetic_algorithm(parsed_query: ParsedQuery, population_size: int = 10, iterations: int = 20, mutation_rate: float = 0.3): ParsedQuery
        ' Traditional Plan Generators (6 strategies)
        - _generate_selection_first_plan(tree: QueryTree): QueryTree
        - _generate_projection_first_plan(tree: QueryTree): QueryTree
        - _generate_balanced_plan(tree: QueryTree): QueryTree
        - _generate_aggressive_combination_plan(tree: QueryTree): QueryTree
        - _generate_conservative_plan(tree: QueryTree): QueryTree
        - _generate_swap_optimized_plan(tree: QueryTree): QueryTree
        ' Genetic Algorithm Methods
        - _initialize_population(original_tree: QueryTree, population_size: int): List[Tuple]
        - _generate_random_rule_sequence(all_rules: List[int]): List[int]
        - _apply_rule_sequence(tree: QueryTree, rule_sequence: List[int]): QueryTree
        - _rule_name(rule_id: int): str
        - _selection(population: List[Tuple], tournament_size: int = 3): Tuple
        - _crossover(seq1: List[int], seq2: List[int]): Tuple[List[int], List[int]]
        - _mutate(rule_sequence: List[int]): List[int]
        - _remove_duplicates_preserve_order(seq: List[int]): List[int]
    }

    class CostCalculator {
        - statistics: Statistics
        - use_real_storage: bool
        + __init__(statistics: Statistics = None, use_real_storage: bool = False): void
        + get_cost(parsed_query: ParsedQuery): int
        - _calculate_tree_cost(tree: QueryTree): int
        + calculate_node_cost(node: QueryTree): int
        ' Cost calculation methods for different operations
        - _calculate_table_cost(tree: QueryTree): int
        - _calculate_select_cost(tree: QueryTree): int
        - _calculate_project_cost(tree: QueryTree): int
        - _calculate_join_cost(tree: QueryTree): int
        - _calculate_natural_join_cost(tree: QueryTree): int
        - _calculate_hash_join_cost(tree: QueryTree): int
        - _calculate_cartesian_product_cost(tree: QueryTree): int
        - _calculate_order_by_cost(tree: QueryTree): int
        - _calculate_update_cost(tree: QueryTree): int
        - _calculate_limit_cost(tree: QueryTree): int
        - _estimate_selectivity(condition: Any, tree: QueryTree): float
        - _estimate_condition_selectivity(condition_node: ConditionNode, tree: QueryTree): float
    }

    class Statistics {
        - storage_adapter: StorageAdapter
        - cache: Dict[str, Dict]
        - relations: Dict[str, Dict]
        + __init__(storage_adapter: StorageAdapter = None): void
        + add_relation(relation_name: str, nr: int, lr: int, br: int = None, fr: int = None): void
        + add_distinct_values(relation_name: str, attribute: str, count: int): void
        + get_relation_stats(relation_name: str): Dict
        + get_distinct_values(relation_name: str, attribute: str): int
        + clear_cache(): void
    }

    class OptimizationRules {
        ' Main optimization rules (8 rules dari spesifikasi)
        + {static} push_down_selection(tree: QueryTree): QueryTree
        + {static} push_down_projection(tree: QueryTree): QueryTree
        + {static} combine_selections(tree: QueryTree): QueryTree
        + {static} swap_selection(tree: QueryTree): QueryTree
        + {static} combine_cartesian_with_selection(tree: QueryTree): QueryTree
        + {static} reorder_joins(tree: QueryTree): QueryTree
        + {static} apply_associativity(tree: QueryTree): QueryTree
        + {static} distribute_selection_over_join(tree: QueryTree): QueryTree
        ' Helper methods
        - {static} _helper_distribute_projection_over_join(tree: QueryTree): QueryTree
        - {static} _attribute_belongs_to(attr: str, table_attrs: List[str]): bool
        - {static} _decompose_conjunctive_selection(selection_node: QueryTree): QueryTree
        - {static} _extract_and_conditions(condition_node: ConditionNode): List[ConditionNode]
        - {static} _get_attributes_from_tree(tree: QueryTree): List[str]
        - {static} _get_attributes_from_condition(condition: ConditionNode): List[str]
    }
}

' Interface Storage Manager
package "Interface Storage" {
    class StorageAdapter {
        - use_real_storage: bool
        + __init__(use_real_storage: bool = True): void
        + get_table_statistics(table_name: str): Dict
        + update_statistics(table_name: str): void
        + is_available: bool
    }
}

' Relasi antar kelas
' OptimizationEngine memiliki (composition) semua komponen utama
OptimizationEngine *-- Parser : memiliki
OptimizationEngine *-- QueryValidator : memiliki
OptimizationEngine *-- PlanOptimizer : memiliki
OptimizationEngine *-- CostCalculator : memiliki

' Parser dan komponennya
Parser *-- Lexer : memiliki
Parser ..> ParsedQuery : membuat
Parser ..> QueryTree : membuat
Parser ..> ConditionNode : membuat

' QueryValidator memvalidasi hasil parsing
QueryValidator ..> ParsedQuery : memvalidasi
QueryValidator ..> QueryTree : memvalidasi

' Struktur tree dan node
ParsedQuery *-- QueryTree : berisi
QueryTree --> NodeType : menggunakan
QueryTree *-- ConditionNode : dapat berisi

' Hierarki ConditionNode
ConditionNode <|-- ConditionOperator
ConditionNode <|-- ConditionLeaf
ConditionOperator o-- ConditionNode : kiri/kanan

' PlanOptimizer dan rules
PlanOptimizer *-- OptimizationRules : memiliki
PlanOptimizer --> CostCalculator : menggunakan
PlanOptimizer ..> ParsedQuery : transformasi
PlanOptimizer ..> QueryTree : memanipulasi

OptimizationRules ..> QueryTree : transformasi

' CostCalculator dan statistik
CostCalculator *-- Statistics : memiliki
CostCalculator ..> ParsedQuery : menganalisis
CostCalculator ..> QueryTree : menghitung

' Statistics dan StorageAdapter
Statistics o-- StorageAdapter : dapat memiliki

@enduml
