@startuml Query Optimizer Class Diagram

title Query Optimizer - Class Diagram


' Komponen utama interface
package "Query Optimizer" {
    class OptimizationEngine {
        - parser: Parser
        - validator: QueryValidator
        - plan_optimizer: PlanOptimizer
        - cost_calculator: CostCalculator
        + __init__(): void
        + parse_query(query: str): ParsedQuery
        + optimize_query(query: ParsedQuery): ParsedQuery
        + get_cost(query: ParsedQuery): int
    }
}

' Struktur tree
package "Komponen Tree" {
    class ParsedQuery {
        - query: str
        - query_tree: QueryTree
        - tables: List[str]
        + __init__(query: str, query_tree: QueryTree)
        + collect_tables(node: QueryTree): void
        + print_tree(node: QueryTree, level: int): void
    }

    class QueryTree {
        - type: str
        - val: Any
        - childs: List[QueryTree]
        - parent: QueryTree
        + __init__(type: str, val: Any, childs: List[QueryTree], parent: QueryTree)
        + add_child(child: QueryTree): void
        + print_tree(level: int): void
        + condition_node_to_string(node: ConditionNode): str
        + __str__(): str
    }
}

' Tipe node dan kondisi
package "Komponen Node" {
    enum NodeType {
        PROJECT
        SELECT
        TABLE
        JOIN
        CARTESIAN_PRODUCT
        NATURAL_JOIN
        HASH_JOIN
        UPDATE
        SET
        ORDER_BY
        GROUP_BY
        HAVING
        LIMIT
        CONDITION
        + __str__(): str
    }

    abstract class ConditionNode {
    }

    class ConditionOperator {
        - operator: str
        - left: ConditionNode
        - right: ConditionNode
        + __init__(operator: str, left: ConditionNode, right: ConditionNode)
        + __eq__(other: ConditionOperator): bool
        + __repr__(): str
    }

    class ConditionLeaf {
        - condition: str
        + __init__(condition: str)
        + __eq__(other: ConditionLeaf): bool
        + __repr__(): str
    }
}

' Komponen parser
package "Komponen Parser" {
    class Parser {
        - lexer: Lexer
        + __init__(): void
        + parse_query(query: str): ParsedQuery
        + parse_condition(condition_tokens: List[str]): ConditionNode
    }

    class Lexer {
        + tokenize(query: str): List[str]
        + KEYWORDS: Set[str]
    }

    class QueryValidator {
        + validate_parsed_query(parsed_query: ParsedQuery): Tuple[bool, List[str]]
        - _validate_tree_structure(node: QueryTree, visited: Set): List[str]
    }
}

' Komponen optimizer
package "Komponen Optimisasi" {
    class PlanOptimizer {
        - rules: OptimizationRules
        + __init__(): void
        + optimize_tree(parsed_query: ParsedQuery): ParsedQuery
    }

    class CostCalculator {
        - statistics: Statistic
        + __init__(statistics: Statistic): void
        + get_cost(parsed_query: ParsedQuery): int
        + calculate_node_cost(node: QueryTree): int
        - _calculate_tree_cost(tree: QueryTree): int
    }

    class OptimizationRules {
        + {static} push_down_selection(tree: QueryTree): QueryTree
        + {static} push_down_projection(tree: QueryTree): QueryTree
        + {static} combine_selections(tree: QueryTree): QueryTree
        + {static} combine_cartesian_with_selection(tree: QueryTree): QueryTree
        + {static} reorder_joins(tree: QueryTree): QueryTree
        + {static} apply_associativity(tree: QueryTree): QueryTree
        + {static} distribute_selection_over_join(tree: QueryTree): QueryTree
        + {static} distribute_projection_over_join(tree: QueryTree): QueryTree
    }
}

' Interface statistik untuk Storage Manager
package "Interface Storage" {
    class Statistics {
        - relations: Dict[str, Dict]
        + __init__(): void
        + add_relation(relation_name: str, nr: int, lr: int, br: int, fr: int): void
        + add_distinct_values(relation_name: str, attribute: str, count: int): void
        + get_relation_stats(relation_name: str): Dict
        + get_distinct_values(relation_name: str, attribute: str): int
    }
}

' Relasi antar kelas
' OptimizationEngine memiliki (composition) semua komponen utama
OptimizationEngine *-- Parser : memiliki
OptimizationEngine *-- QueryValidator : memiliki
OptimizationEngine *-- PlanOptimizer : memiliki
OptimizationEngine *-- CostCalculator : memiliki

' Parser dan komponennya
Parser *-- Lexer : memiliki
Parser ..> ParsedQuery : membuat
Parser ..> QueryTree : membuat
Parser ..> ConditionNode : membuat

' QueryValidator memvalidasi hasil parsing
QueryValidator ..> ParsedQuery : memvalidasi
QueryValidator ..> QueryTree : memvalidasi

' Struktur tree dan node
ParsedQuery *-- QueryTree : berisi
QueryTree --> NodeType : menggunakan
QueryTree *-- ConditionNode : dapat berisi

' Hierarki ConditionNode
ConditionNode <|-- ConditionOperator
ConditionNode <|-- ConditionLeaf
ConditionOperator o-- ConditionNode : kiri/kanan

' PlanOptimizer dan rules
PlanOptimizer *-- OptimizationRules : memiliki
PlanOptimizer ..> ParsedQuery : transformasi
PlanOptimizer ..> QueryTree : memanipulasi

OptimizationRules ..> QueryTree : transformasi

' CostCalculator dan statistik
CostCalculator o-- Statistics : dapat memiliki
CostCalculator ..> ParsedQuery : menganalisis
CostCalculator ..> QueryTree : menghitung


' Additional notes for clarity
'
' note right of OptimizationEngine
'     Interface utama untuk komponen Query Optimizer.
'     Mengintegrasikan seluruh komponen dalam alur:
'     Parse → Validate → Optimize → Calculate Cost

'     Method dari spesifikasi:
'     1. parse_query - parsing & validasi SQL
'     2. optimize_query - optimasi menggunakan rules
'     3. get_cost - kalkulasi biaya eksekusi
' end note

' note bottom of QueryValidator
'     Komponen validasi yang ditambahkan untuk memastikan:
'     - Query tree memiliki struktur yang valid
'     - Tidak ada cycle dalam tree
'     - Semua komponen esensial tersedia
'     - Setiap node memiliki tipe yang benar

'     Memberikan early detection sebelum optimisasi.
' end note

' note right of OptimizationRules
'     Mengimplementasikan 8 aturan transformasi
'     berdasarkan aturan ekivalensi relasional:

'     1. Push-down selection
'     2. Push-down projection
'     3. Combine selections
'     4. Combine Cartesian with selection (→ join)
'     5. Reorder joins (commutativity)
'     6. Apply associativity
'     7. Distribute selection over join
'     8. Distribute projection over join

'     Semua method bersifat static untuk transformasi tree.
' end note

' note left of PlanOptimizer
'     Orchestrator yang menerapkan aturan optimisasi
'     secara berurutan mengikuti strategi heuristik:

'     1. Push-down operations
'     2. Combine & convert operations
'     3. Join optimization

'     Mengembalikan ParsedQuery yang telah dioptimasi
'     dengan logging untuk setiap tahap transformasi.
' end note

' note bottom of Statistics
'     Mengelola statistik relasi untuk perhitungan biaya:
'     - nr: jumlah tuple dalam relasi r
'     - br: jumlah blok yang berisi tuple dari r
'     - lr: ukuran tuple dari r
'     - fr: blocking factor dari r
'     - V(A,r): nilai distinct dalam r untuk atribut A
'
'     Menyediakan default values untuk relasi tanpa statistik
'     dan dapat menghitung parameter yang hilang secara otomatis.
' end note

' note left of QueryTree
'     Representasi tree dari parsed query.
'     Setiap node memiliki tipe (NodeType) dan nilai.
'     Mendukung operasi seperti PROJECT, SELECT,
'     JOIN, TABLE, ORDER_BY, GROUP_BY, HAVING, dll.

'     Tree structure dengan parent-child relationship
'     memungkinkan traversal dan transformasi.
' end note

' note bottom of CostCalculator
'     Menghitung estimasi biaya eksekusi query
'     menggunakan pendekatan rekursif bottom-up.

'     Formula biaya untuk berbagai operasi:
'     - TABLE: br (number of blocks)
'     - SELECT: scan cost + evaluation cost
'     - JOIN: nested loop / hash / merge join
'     - PROJECT: child cost + projection cost

'     Menggunakan statistik dari Storage Manager.
' end note

@enduml
