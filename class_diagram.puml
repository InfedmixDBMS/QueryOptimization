@startuml Query Optimizer Class Diagram

title Query Optimizer - Class Diagram (Updated Implementation)


' Komponen utama interface
package "Query Optimizer" {
    class OptimizationEngine {
        - parser: Parser
        - validator: QueryValidator
        - plan_optimizer: PlanOptimizer
        - cost_calculator: CostCalculator
        + __init__(): void
        + parse_query(query: str): ParsedQuery
        + optimize_query(query: ParsedQuery): ParsedQuery
        + get_cost(query: ParsedQuery): int
    }
}

' Struktur tree
package "Komponen Tree" {
    class ParsedQuery {
        - query: str
        - query_tree: QueryTree
        - tables: List[str]
        + __init__(query: str, query_tree: QueryTree): void
        + collect_tables(node: QueryTree): void
        + print_tree(node: QueryTree = None, level: int = 0): void
    }

    class QueryTree {
        - type: str
        - val: Any
        - childs: List[QueryTree]
        - parent: QueryTree
        + __init__(type: str, val: Any, childs: List[QueryTree] = [], parent: QueryTree = None): void
        + add_child(child: QueryTree): void
        + print_tree(level: int = 0): void
        + condition_node_to_string(node: ConditionNode): str
        + __str__(): str
    }
}

' Tipe node dan kondisi
package "Komponen Node" {
    enum NodeType {
        PROJECT
        SELECT
        TABLE
        JOIN
        CARTESIAN_PRODUCT
        NATURAL_JOIN
        HASH_JOIN
        UPDATE
        SET
        ORDER_BY
        GROUP_BY
        HAVING
        LIMIT
        CONDITION
        + __str__(): str
    }

    abstract class ConditionNode {
    }

    class ConditionOperator {
        - operator: str
        - left: ConditionNode
        - right: ConditionNode
        + __init__(operator: str, left: ConditionNode, right: ConditionNode): void
        + __eq__(other: ConditionOperator): bool
        + __repr__(): str
    }

    class ConditionLeaf {
        - condition: str
        + __init__(condition: str): void
        + __eq__(other: ConditionLeaf): bool
        + __repr__(): str
    }
}

' Komponen parser
package "Komponen Parser" {
    class Parser {
        - lexer: Lexer
        + __init__(): void
        + parse_query(query: str): ParsedQuery
        + parse_condition(condition_tokens: List[str]): ConditionNode
    }

    class Lexer {
        + tokenize(query: str): List[str]
        + KEYWORDS: Set[str]
    }

    class QueryValidator {
        + validate_parsed_query(parsed_query: ParsedQuery): Tuple[bool, List[str]]
        - _validate_tree_structure(node: QueryTree, visited: Set): List[str]
    }
}

' Komponen optimizer
package "Komponen Optimisasi" {
    class PlanOptimizer {
        - rules: OptimizationRules
        - cost_calculator: CostCalculator
        + __init__(): void
        + optimize_tree(parsed_query: ParsedQuery): ParsedQuery
        - _generate_selection_first_plan(tree: QueryTree): QueryTree
        - _generate_projection_first_plan(tree: QueryTree): QueryTree
        - _generate_balanced_plan(tree: QueryTree): QueryTree
        - _generate_aggressive_combination_plan(tree: QueryTree): QueryTree
        - _generate_conservative_plan(tree: QueryTree): QueryTree
    }

    class CostCalculator {
        - statistics: Statistics
        + __init__(statistics: Statistics = None): void
        - _init_default_statistics(): void
        + get_cost(parsed_query: ParsedQuery): int
        + calculate_node_cost(node: QueryTree): int
        - _calculate_tree_cost(tree: QueryTree): int
    }

    class OptimizationRules {
        ' Main optimization rules (8 rules dari spesifikasi)
        + {static} push_down_selection(tree: QueryTree): QueryTree
        + {static} push_down_projection(tree: QueryTree): QueryTree
        + {static} combine_selections(tree: QueryTree): QueryTree
        + {static} swap_selection(tree: QueryTree): QueryTree
        + {static} combine_cartesian_with_selection(tree: QueryTree): QueryTree
        + {static} reorder_joins(tree: QueryTree): QueryTree
        + {static} apply_associativity(tree: QueryTree): QueryTree
        + {static} distribute_selection_over_join(tree: QueryTree): QueryTree
        + {static} distribute_projection_over_join(tree: QueryTree): QueryTree
        ' Helper methods
        - {static} _helper_distribute_projection_over_join(tree: QueryTree): QueryTree
        - {static} _attribute_belongs_to(attr: str, table_attrs: List[str]): bool
        - {static} _decompose_conjunctive_selection(selection_node: QueryTree): QueryTree
        - {static} _extract_and_conditions(condition_node: ConditionNode): List[ConditionNode]
        - {static} _get_attributes_from_tree(tree: QueryTree): List[str]
        - {static} _get_attributes_from_condition(condition: ConditionNode): List[str]
    }
}

' Interface statistik untuk Storage Manager
package "Interface Storage" {
    class Statistics {
        - relations: Dict[str, Dict]
        + __init__(): void
        + add_relation(relation_name: str, nr: int, lr: int, br: int = None, fr: int = None): void
        + add_distinct_values(relation_name: str, attribute: str, count: int): void
        + get_relation_stats(relation_name: str): Dict
        + get_distinct_values(relation_name: str, attribute: str): int
    }
}

' Relasi antar kelas
' OptimizationEngine memiliki (composition) semua komponen utama
OptimizationEngine *-- Parser : memiliki
OptimizationEngine *-- QueryValidator : memiliki
OptimizationEngine *-- PlanOptimizer : memiliki
OptimizationEngine *-- CostCalculator : memiliki

' Parser dan komponennya
Parser *-- Lexer : memiliki
Parser ..> ParsedQuery : membuat
Parser ..> QueryTree : membuat
Parser ..> ConditionNode : membuat

' QueryValidator memvalidasi hasil parsing
QueryValidator ..> ParsedQuery : memvalidasi
QueryValidator ..> QueryTree : memvalidasi

' Struktur tree dan node
ParsedQuery *-- QueryTree : berisi
QueryTree --> NodeType : menggunakan
QueryTree *-- ConditionNode : dapat berisi

' Hierarki ConditionNode
ConditionNode <|-- ConditionOperator
ConditionNode <|-- ConditionLeaf
ConditionOperator o-- ConditionNode : kiri/kanan

' PlanOptimizer dan rules
PlanOptimizer *-- OptimizationRules : memiliki
PlanOptimizer --> CostCalculator : menggunakan
PlanOptimizer ..> ParsedQuery : transformasi
PlanOptimizer ..> QueryTree : memanipulasi

OptimizationRules ..> QueryTree : transformasi

' CostCalculator dan statistik
CostCalculator o-- Statistics : dapat memiliki
CostCalculator ..> ParsedQuery : menganalisis
CostCalculator ..> QueryTree : menghitung


' note right of OptimizationEngine
'     Interface utama untuk komponen Query Optimizer.
'     Mengintegrasikan seluruh komponen dalam alur:
'     Parse → Validate → Optimize → Calculate Cost

'     Method dari spesifikasi:
'     1. parse_query - parsing & validasi SQL
'     2. optimize_query - optimasi menggunakan rules
'     3. get_cost - kalkulasi biaya eksekusi
' end note

' note bottom of QueryValidator
'     Komponen validasi yang ditambahkan untuk memastikan:
'     - Query tree memiliki struktur yang valid
'     - Tidak ada cycle dalam tree
'     - Semua komponen esensial tersedia
'     - Setiap node memiliki tipe yang benar

'     Memberikan early detection sebelum optimisasi.
' end note

' note right of OptimizationRules
'     Mengimplementasikan 8 aturan transformasi
'     berdasarkan aturan ekivalensi relasional:

'     1. Conjunctive Selection Decomposition (push_down_selection)
'     2. Selection Commutativity (swap_selection)
'     3. Projection Cascade Elimination (push_down_projection)
'     4. Combine Cartesian with selection (→ join)
'     5. Join Commutativity (reorder_joins)
'     6. Join Associativity (apply_associativity)
'     7. Distribute selection over join
'     8. Distribute projection over join

'     Helper Methods:
'     • _helper_distribute_projection_over_join
'     • _attribute_belongs_to
'     • _decompose_conjunctive_selection
'     • _extract_and_conditions
'     • _get_attributes_from_tree
'     • _get_attributes_from_condition

'     Status: 6/8 rules implemented (75%)
' end note

' note left of PlanOptimizer
'     Orchestrator yang menerapkan aturan optimisasi
'     dengan strategi multiple plan selection:

'     Multiple Plan Generation:
'     1. Selection-First Plan (Standard Heuristic)
'     2. Projection-First Plan
'     3. Balanced Plan (Alternating)
'     4. Aggressive Combination Plan
'     5. Conservative Plan (Minimal)

'     Setiap plan dievaluasi cost-nya,
'     dan plan dengan cost terendah dipilih.

'     Mengembalikan ParsedQuery yang telah dioptimasi
'     dengan logging untuk setiap tahap transformasi.
' end note

' note bottom of Statistics
'     Mengelola statistik relasi untuk perhitungan biaya:
'     - nr: jumlah tuple dalam relasi r
'     - br: jumlah blok yang berisi tuple dari r
'     - lr: ukuran tuple dari r
'     - fr: blocking factor dari r
'     - V(A,r): nilai distinct dalam r untuk atribut A

'     Menyediakan default values untuk relasi tanpa statistik
'     dan dapat menghitung parameter yang hilang secara otomatis.
    
'     Parameter br dan fr bersifat optional dengan auto-calculation.
' end note

' note left of QueryTree
'     Representasi tree dari parsed query.
'     Setiap node memiliki tipe (NodeType) dan nilai.
'     Mendukung operasi seperti PROJECT, SELECT,
'     JOIN, TABLE, ORDER_BY, GROUP_BY, HAVING, dll.

'     Tree structure dengan parent-child relationship
'     memungkinkan traversal dan transformasi.
    
'     Default parameters: childs=[], parent=None
' end note

' note bottom of CostCalculator
'     Menghitung estimasi biaya eksekusi query
'     menggunakan pendekatan rekursif bottom-up.

'     Formula biaya untuk berbagai operasi:
'     - TABLE: br (number of blocks)
'     - SELECT: scan cost + evaluation cost
'     - JOIN: nested loop / hash / merge join
'     - PROJECT: child cost + projection cost

'     Menggunakan statistik dari Statistics class.
'     Auto-initialize default statistics jika tidak disediakan.
' end note

@enduml
